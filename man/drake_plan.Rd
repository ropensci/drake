% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api-plan.R
\name{drake_plan}
\alias{drake_plan}
\title{Create a workflow plan data frame
for the \code{plan} argument of \code{\link[=make]{make()}}.}
\usage{
drake_plan(..., list = character(0), file_targets = NULL,
  strings_in_dots = NULL, tidy_evaluation = TRUE)
}
\arguments{
\item{...}{A collection of symbols/targets
with commands assigned to them. See the examples for details.}

\item{list}{A named character vector of commands
with names as targets.}

\item{file_targets}{deprecated}

\item{strings_in_dots}{deprecated}

\item{tidy_evaluation}{logical, whether to use tidy evaluation
such as quasiquotation
when evaluating commands passed through the free-form
\code{...} argument.}
}
\value{
A data frame of targets and commands. See the details
for optional columns you can append manually post-hoc.
}
\description{
Turns a named collection of target/command pairs into
a workflow plan data frame for \code{\link[=make]{make()}}. You can give the commands
as named expressions, or you can use the \code{list}
argument to supply them as character strings.
}
\details{
A workflow plan data frame is a data frame
with a \code{target} column and a \code{command} column.
Targets are the R objects that \code{drake} generates,
and commands are the pieces of R code that produce them.

The commands that return targets may also depend on
external files and create multiple external files.
To signal that you are creating and/or depending on
custom files in your commands,
use the \code{\link[=file_in]{file_in()}}, \code{\link[=knitr_in]{knitr_in()}}, and
\code{\link[=file_out]{file_out()}} functions in your commands.
the examples in this help file provide some guidance.

Besides the \code{target} and \code{command} columns, there are optional columns
you may append to your workflow plan data frame:
\itemize{
\item \code{trigger}: a character vector of triggers. A trigger is a rule for
when to cause a target to (re)build. See \code{\link[=triggers]{triggers()}} for your options.
For a walkthrough, see
\url{https://ropenscilabs.github.io/drake-manual/debug.html}
\item \code{retries}: number of times to retry a target if it fails
to build the first time.
\item \code{timeout}: Seconds of overall time to allow before imposing
a timeout on a target.
Assign target-level timeout times with an optional \code{timeout}
column in \code{plan}.
\item \code{cpu}: Seconds of cpu time to allow before imposing
a timeout on a target.
Assign target-level cpu timeout times with an optional \code{cpu}
column in \code{plan}.
\item \code{elapsed}: Seconds of elapsed time to allow before imposing
a timeout on a target.
Assign target-level elapsed timeout times with an optional \code{elapsed}
column in \code{plan}.
\item \code{resources}: Experimental, no guarantees that this works all the time.
\code{resources} is a list column. Each element is a named list,
same as the \code{resources} argument to \code{batchtools_slurm()}
and related \code{future.bachtools} functions. See also
\url{https://github.com/HenrikBengtsson/future.batchtools#examples}. # nolint
\code{resources[[target_name]]} is a list of
computing resource parameters for the target.
Each element is a value passed to a \code{brew} placeholder of a
\code{batchtools} template file.
The list names of \code{resources[[target_name]]}
should be the brew patterns.
}
}
\examples{
test_with_dir("Contain side effects", {
# Create workflow plan data frames.
mtcars_plan <- drake_plan(
  write.csv(mtcars[, c("mpg", "cyl")], file_out("mtcars.csv")),
  value = read.csv(file_in("mtcars.csv"))
)
mtcars_plan
make(mtcars_plan) # Makes `mtcars.csv` and then `value`
head(readd(value))
# You can use knitr inputs too. See the top command below.
load_mtcars_example()
head(my_plan)
# The `knitr_in("report.Rmd")` tells `drake` to dive into the active
# code chunks to find dependencies.
# There, `drake` sees that `small`, `large`, and `coef_regression2_small`
# are loaded in with calls to `loadd()` and `readd()`.
deps_code("report.Rmd")
# You can create your own custom columns too.
# See ?triggers for more on triggers.
drake_plan(
  website_data = target(
    command = download_data("www.your_url.com"),
    trigger = "always",
    custom_column = 5
  ),
  analysis = analyze(website_data)
)
# Are you a fan of tidy evaluation?
my_variable <- 1
drake_plan(
  a = !!my_variable,
  b = !!my_variable + 1,
  list = c(d = "!!my_variable")
)
drake_plan(
  a = !!my_variable,
  b = !!my_variable + 1,
  list = c(d = "!!my_variable"),
  tidy_evaluation = FALSE
)
# For instances of !! that remain unevaluated in the workflow plan,
# make() will run these commands in tidy fashion,
# evaluating the !! operator using the environment you provided.
})
}
\seealso{
\code{\link[=map_plan]{map_plan()}}, \code{\link[=reduce_by]{reduce_by()}}, \code{\link[=gather_by]{gather_by()}}, \code{\link[=reduce_plan]{reduce_plan()}}, \code{\link[=gather_plan]{gather_plan()}},
\code{\link[=evaluate_plan]{evaluate_plan()}}, \code{\link[=expand_plan]{expand_plan()}}
}
