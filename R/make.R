#' @title Function \code{make}
#' @description Run your project (build the targets).
#' @seealso \code{\link{plan}}, \code{\link{plot_graph}},
#' \code{\link{max_useful_jobs}}, \code{\link{shell_file}}
#' @export
#' @param plan workflow plan data frame.
#' A workflow plan data frame is a data frame
#' with a \code{target} column and a \code{command} column.
#' Targets are the objects and files that drake generates,
#' and commands are the pieces of R code that produce them.
#' Use the function \code{\link{plan}()} to generate workflow plan
#' data frames easily, and see functions \code{\link{analyses}()},
#' \code{\link{summaries}()}, \code{\link{evaluate}()},
#' \code{\link{expand}()}, and \code{\link{gather}()} for
#' easy ways to generate large workflow plan data frames.
#'
#' @param targets character string, names of targets to build.
#' Dependencies are built too.
#'
#' @param envir environment to use. Defaults to the current
#' workspace, so you should not need to worry about this
#' most of the time. A deep copy of \code{envir} is made,
#' so you don't need to worry about your workspace being modified
#' by \code{make}. The deep copy inherits from the global environment.
#' Wherever necessary, objects and functions are imported
#' from \code{envir} and the global environment and
#' then reproducibly tracked as dependencies.
#'
#' @param verbose logical, whether to print progress to the console.
#' Skipped objects are not printed.
#'
#' @param imports_only logical, whether to skip building the targets
#' in \code{plan} and just import objects and files.
#'
#' @param parallelism character, type of parallelism to use.
#' To list the options, call \code{\link{parallelism_choices}()}.
#' For detailed explanations, see \code{?\link{parallelism_choices}},
#' the tutorial vignettes, or the tutorial files generated by
#' \code{\link{example_drake}("basic")}
#'
#' @param jobs number of parallel processes or jobs to run.
#' See \code{\link{max_useful_jobs}()} or \code{\link{plot_graph}()}
#' to help figure out what the number of jobs should be.
#' Windows users should not set \code{jobs > 1} if
#' \code{parallelism} is \code{"mclapply"} because
#' \code{\link{mclapply}()} is based on forking. Windows users
#' who use \code{parallelism == "Makefile"} will need to
#' download and install Rtools.
#'
#' If \code{parallelism} is \code{"Makefile"},  Makefile-level parallelism is
#' only used for targets in your workflow plan data frame, not imports.  To
#' process imported objects and files, drake selects the best parallel backend
#' for your system and uses the number of jobs you give to the \code{jobs}
#' argument to \code{\link{make}()}. To use at most 2 jobs for imports and at
#' most 4 jobs for targets, run
#' \code{make(..., parallelism = "Makefile", jobs = 2, args = "--jobs=4")}
#'
#' @param packages character vector packages to load, in the order
#' they should be loaded. Defaults to \code{(.packages())}, so you
#' shouldn't usually need to set this manually. Just call
#' \code{\link{library}()} to load your packages before \code{make()}.
#' However, sometimes packages need to be strictly forced to load
#' in a certian order, especially if \code{parallelism} is
#' \code{"Makefile"}. To do this, do not use \code{\link{library}()}
#' or \code{\link{require}()} or \code{\link{loadNamespace}()} or
#' \code{\link{attachNamespace}()} to load any libraries beforehand.
#' Just list your packages in the \code{packages} argument in the order
#' you want them to be loaded.
#' If \code{parallelism} is \code{"mclapply"},
#' the necessary packages
#' are loaded once before any targets are built. If \code{parallelism} is
#' \code{"Makefile"}, the necessary packages are loaded once on
#' initialization and then once again for each target right
#' before that target is built.
#'
#' @param prework character vector of lines of code to run
#' before build time. This code can be used to
#' load packages, set options, etc., although the packages in the
#' \code{packages} argument are loaded before any prework is done.
#' If \code{parallelism} is \code{"mclapply"}, the \code{prework}
#' is run once before any targets are built. If \code{parallelism} is
#' \code{"Makefile"}, the prework is run once on initialization
#' and then once again for each target right before that target is built.
#'
#' @param prepend lines to prepend to the Makefile if \code{parallelism}
#' is \code{"Makefile"}. See the vignettes
#' (\code{vignette(package = "drake")})
#' to learn how to use \code{prepend}
#' to take advantage of multiple nodes of a supercomputer.
#'
#' @param command character scalar, command to call the Makefile
#' generated for distributed computing.
#' Only applies when \code{parallelism} is \code{"Makefile"}.
#' Defaults to the usual \code{"make"}, but it could also be
#' \code{"lsmake"} on supporting systems, for example.
#' \code{command} and \code{args} are executed via
#' \code{\link{system2}(command, args)} to run the Makefile.
#' If \code{args} has something like \code{"--jobs=2"}, or if
#' \code{jobs >= 2} and \code{args} is left alone, targets
#' will be distributed over independent parallel R sessions
#' wherever possible.
#'
#' @param args command line arguments to call the Makefile for
#' distributed computing. For advanced users only. If set,
#' \code{jobs} and \code{verbose} are overwritten as they apply to the
#' Makefile.
#' \code{command} and \code{args} are executed via
#' \code{\link{system2}(command, args)} to run the Makefile.
#' If \code{args} has something like \code{"--jobs=2"}, or if
#' \code{jobs >= 2} and \code{args} is left alone, targets
#' will be distributed over independent parallel R sessions
#' wherever possible.
#'
#' @param return_config logical, whether to return the internal list
#' of runtime configuration parameters used by \code{make()}
#'
#' @param clear_progress logical, whether to clear the saved record of
#' progress seen by \code{\link{progress}()} and \code{\link{in_progress}()}
#' before anything is imported or built.
#' 
#' @param short_hash_algo character scalar, name of the short
#' hash algorithm to use. Drake uses both a short hash algorithm
#' for fingerprints that could be file names and a long
#' hash algorithm for fingerprints that are never file names.
#' Windows restricts the length of file paths, so the
#' distinction is important.
#'
#' @param long_hash_algo character scalar, name of the long
#' hash algorithm to use. Drake uses both a short hash algorithm
#' for fingerprints that could be file names and a long
#' hash algorithm for fingerprints that are never file names.
#' Windows restricts the length of file paths, so the
#' distinction is important.
#'
#' @examples
#' \dontrun{
#' load_basic_example()
#' outdated(my_plan) # Which targets need to be (re)built?
#' my_jobs = max_useful_jobs(my_plan) # Depends on what is up to date.
#' make(my_plan, jobs = my_jobs) # Build what needs to be built.
#' outdated(my_plan) # Everything is up to date.
#' reg2 = function(d){ # Change one of your functions.
#'  d$x3 = d$x^3
#'   lm(y ~ x3, data = d)
#' }
#' outdated(my_plan) # Some targets depend on reg2().
#' plot_graph(my_plan) # See how they fit in an interactive graph.
#' make(my_plan) # Rebuild just the outdated targets.
#' outdated(my_plan) # Everything is up to date again.
#' plot_graph(my_plan) # The colors changed in the graph.
#' }
make <- function(
  plan,
  targets = drake::possible_targets(plan),
  envir = parent.frame(),
  verbose = TRUE,
  imports_only = FALSE,
  parallelism = drake::default_parallelism(),
  jobs = 1,
  packages = (.packages()),
  prework = character(0),
  prepend = character(0),
  command = "make",
  args = drake::default_system2_args(
    jobs = jobs,
    verbose = verbose
    ),
  return_config = FALSE,
  clear_progress = TRUE,
  short_hash_algo = drake::default_short_hash_algo(),
  long_hash_algo = drake::default_long_hash_algo()
){
  force(envir)
  parallelism <- match.arg(
    arg = parallelism,
    choices = parallelism_choices()
    )
  config <- build_config(
    plan = plan,
    targets = targets,
    envir = envir,
    verbose = verbose,
    parallelism = parallelism,
    jobs = jobs,
    packages = packages,
    prework = prework,
    prepend = prepend,
    command = command,
    args = args,
    clear_progress = clear_progress,
    short_hash_algo = short_hash_algo,
    long_hash_algo = long_hash_algo
  )
  check_config(config)
  store_config(config)
  config$cache$set(
    key = "sessionInfo",
    value = sessionInfo(),
    namespace = "session"
    )
  if (imports_only){
    delete_these <- intersect(config$plan$target, V(config$graph)$name)
    config$graph <- delete_vertices(config$graph, v = delete_these)
    if (parallelism == "Makefile"){
      parallelism <- default_parallelism()
    }
  }
  get(paste0("run_", parallelism), envir = getNamespace("drake"))(config)
  if (return_config){
    return(config)
  } else{
    return(invisible())
  }
}

next_targets <- function(graph_remaining_targets){
  number_dependencies <- sapply(
    V(graph_remaining_targets),
    function(x){
      adjacent_vertices(graph_remaining_targets, x, mode = "in") %>%
        unlist() %>%
        length()
    }
    )
  which(!number_dependencies) %>%
    names()
}
